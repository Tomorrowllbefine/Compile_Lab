//KMP
#include<iostream>
#include<vector>
#include<string>

//next数组的生成
void getNext(std::vector<int> &next,const std::string& str)
{
	int j = 0;
	next[0] = j;	//首字符无相等前后缀 
	for( int i = 1;i<str.size();i++ )
	{
		while(j > 0 && str[i]!= str[j] ) j = next[j-1]; //前后缀不相同 
		if( str[i] == str[j] ) j++;	//前后缀相同 
		next[i] = j;	//填表 
	} 
}

//匹配字符串
int strStr(std::string& haystack,std::string& needle)
{
	if(needle.size() == 0) return 0;
	std::vector<int> next(needle.size()); 
	getNext(next,needle); //生成next数组
	for(int i =0; i<next.size();i++) std::cout<<next[i]<<" ";
	int j = 0;
	for( int i = 0; i<haystack.size(); i++)
	{
		//失配j向前回退 
		while( j >0 && haystack[i] != needle[j] ) j =next[j-1];
		if( haystack[i] == needle[j] ) j++; //匹配则j向后扫描 
		if(j == needle.size() ) //匹配完子串最后一个字符 
			return (i - needle.size() + 1);
	 } 
	 return -1;
} 

int main()
{
	std::string haystack = "aabaabaaf"; //文本串 
	std::string needle = "abcabcabcabc"; //模式串 
	for(int i =0; i<haystack.size();i++) std::cout<<haystack[i]<<" ";
	std::cout<<std::endl;
	for(int i =0; i<needle.size();i++) std::cout<<needle[i];
	std::cout<<std::endl;
	int res = strStr(haystack,needle);
	//std::cout<<std::endl;
	std::cout<<"res = "<<res<<std::endl;
	
}